"""
Orquestador de Análisis de Vulnerabilidades

Este orquestador coordina el flujo completo de análisis de vulnerabilidades,
integrando todos los servicios de aplicación.
"""

import logging
from typing import List, Optional, Dict, Any
from datetime import datetime

from ...domain.entities import Report, Vulnerability, Analysis, TriageResult
from .report_processing_service import ReportProcessingService
from .static_analysis_service import StaticAnalysisService
from .dynamic_analysis_service import DynamicAnalysisService
from .triage_service import TriageService

logger = logging.getLogger(__name__)


class VulnerabilityAnalysisOrchestrator:
    """Orquestador principal para el análisis completo de vulnerabilidades"""
    
    def __init__(
        self,
        report_processing_service: ReportProcessingService,
        static_analysis_service: StaticAnalysisService,
        dynamic_analysis_service: DynamicAnalysisService,
        triage_service: TriageService
    ):
        self.report_processing_service = report_processing_service
        self.static_analysis_service = static_analysis_service
        self.dynamic_analysis_service = dynamic_analysis_service
        self.triage_service = triage_service
    
    async def run_complete_analysis(
        self,
        pdf_path: str,
        source_path: str,
        target_url: str,
        model: str = "openai:gpt-5-nano",
        skip_static: bool = False,
        skip_dynamic: bool = False
    ) -> TriageResult:
        """
        Ejecuta el flujo completo de análisis de vulnerabilidades
        
        Args:
            pdf_path: Ruta al archivo PDF del reporte
            source_path: Ruta al código fuente
            target_url: URL objetivo para análisis dinámico
            model: Modelo de IA a utilizar
            skip_static: Si omitir el análisis estático
            skip_dynamic: Si omitir el análisis dinámico
            
        Returns:
            Resultado final del triage
        """
        logger.info("Starting complete vulnerability analysis workflow")
        logger.info(f"PDF: {pdf_path}")
        logger.info(f"Source: {source_path}")
        logger.info(f"Target URL: {target_url}")
        logger.info(f"Model: {model}")
        
        try:
            # Paso 1: Procesar reporte PDF
            logger.info("Step 1: Processing PDF report...")
            report, vulnerabilities = await self.report_processing_service.process_pdf_report(pdf_path)
            logger.info(f"Extracted {len(vulnerabilities)} vulnerabilities from report")
            
            all_analyses = []
            
            # Paso 2: Análisis estático (opcional)
            if not skip_static and source_path:
                logger.info("Step 2: Performing static analysis...")
                static_analyses = await self.static_analysis_service.analyze_vulnerabilities(
                    vulnerabilities, source_path
                )
                all_analyses.extend(static_analyses)
                logger.info(f"Generated {len(static_analyses)} static analyses")
            else:
                logger.info("Step 2: Skipping static analysis")
            
            # Paso 3: Análisis dinámico (opcional)
            if not skip_dynamic and target_url:
                logger.info("Step 3: Performing dynamic analysis...")
                dynamic_analyses = await self.dynamic_analysis_service.analyze_vulnerabilities(
                    vulnerabilities, target_url
                )
                all_analyses.extend(dynamic_analyses)
                logger.info(f"Generated {len(dynamic_analyses)} dynamic analyses")
            else:
                logger.info("Step 3: Skipping dynamic analysis")
            
            # Paso 4: Triage final
            logger.info("Step 4: Performing final triage...")
            triage_result = await self.triage_service.perform_triage(
                report.id, vulnerabilities, all_analyses
            )
            logger.info(f"Triage completed with {len(triage_result.consolidated_vulnerability_ids)} consolidated vulnerabilities")
            
            logger.info("Complete vulnerability analysis workflow finished successfully")
            return triage_result
            
        except Exception as e:
            logger.error(f"Error in complete analysis workflow: {e}")
            raise
    
    async def run_report_processing_only(self, pdf_path: str) -> tuple[Report, List[Vulnerability]]:
        """Ejecuta solo el procesamiento del reporte PDF"""
        logger.info(f"Processing PDF report only: {pdf_path}")
        return await self.report_processing_service.process_pdf_report(pdf_path)
    
    async def run_static_analysis_only(
        self, 
        report_id: str, 
        source_path: str
    ) -> List[Analysis]:
        """Ejecuta solo el análisis estático para un reporte existente"""
        logger.info(f"Running static analysis only for report {report_id}")
        
        # Obtener vulnerabilidades del reporte
        vulnerabilities = await self.report_processing_service.get_vulnerabilities_by_report_id(report_id)
        
        # Ejecutar análisis estático
        return await self.static_analysis_service.analyze_vulnerabilities(
            vulnerabilities, source_path
        )
    
    async def run_dynamic_analysis_only(
        self, 
        report_id: str, 
        target_url: str
    ) -> List[Analysis]:
        """Ejecuta solo el análisis dinámico para un reporte existente"""
        logger.info(f"Running dynamic analysis only for report {report_id}")
        
        # Obtener vulnerabilidades del reporte
        vulnerabilities = await self.report_processing_service.get_vulnerabilities_by_report_id(report_id)
        
        # Ejecutar análisis dinámico
        return await self.dynamic_analysis_service.analyze_vulnerabilities(
            vulnerabilities, target_url
        )
    
    async def run_triage_only(self, report_id: str) -> TriageResult:
        """Ejecuta solo el triage para un reporte existente"""
        logger.info(f"Running triage only for report {report_id}")
        
        # Obtener vulnerabilidades y análisis del reporte
        vulnerabilities = await self.report_processing_service.get_vulnerabilities_by_report_id(report_id)
        
        # Obtener todos los análisis relacionados
        all_analyses = []
        for vuln in vulnerabilities:
            analyses = await self.static_analysis_service.get_analysis_by_vulnerability_id(vuln.id)
            all_analyses.extend(analyses)
            
            dynamic_analyses = await self.dynamic_analysis_service.get_analysis_by_vulnerability_id(vuln.id)
            all_analyses.extend(dynamic_analyses)
        
        # Ejecutar triage
        return await self.triage_service.perform_triage(report_id, vulnerabilities, all_analyses)
    
    async def get_analysis_status(self, report_id: str) -> Dict[str, Any]:
        """Obtiene el estado del análisis para un reporte"""
        try:
            report = await self.report_processing_service.get_report_by_id(report_id)
            vulnerabilities = await self.report_processing_service.get_vulnerabilities_by_report_id(report_id)
            
            # Contar análisis por tipo
            static_analyses = []
            dynamic_analyses = []
            
            for vuln in vulnerabilities:
                static = await self.static_analysis_service.get_analysis_by_vulnerability_id(vuln.id)
                dynamic = await self.dynamic_analysis_service.get_analysis_by_vulnerability_id(vuln.id)
                static_analyses.extend(static)
                dynamic_analyses.extend(dynamic)
            
            # Verificar si existe resultado de triage
            triage_result = None
            try:
                triage_result = await self.triage_service.get_triage_result_by_report_id(report_id)
            except:
                pass
            
            return {
                "report_id": report_id,
                "report_created_at": report.created_at,
                "vulnerabilities_count": len(vulnerabilities),
                "static_analyses_count": len(static_analyses),
                "dynamic_analyses_count": len(dynamic_analyses),
                "triage_completed": triage_result is not None,
                "triage_result_id": triage_result.id if triage_result else None,
                "status": "completed" if triage_result else "in_progress"
            }
            
        except Exception as e:
            logger.error(f"Error getting analysis status for report {report_id}: {e}")
            raise