"""
Servicio de Orquestación de Agentes de Triage de Vulnerabilidades

Este servicio coordina el flujo completo de análisis de vulnerabilidades:
1. Procesamiento de reportes PDF
2. Análisis estático de código
3. Análisis dinámico/explotación
4. Triage final y priorización
"""

import asyncio
from typing import List, Optional, Dict, Any
from datetime import datetime
import logging

from ...domain.entities import Report, Vulnerability, Analysis, TriageResult
from ...domain.repositories import (
    ReportRepository, 
    VulnerabilityRepository, 
    AnalysisRepository, 
    TriageResultRepository
)
from ...infrastructure.agents.report_reader import ReportReaderAgent
from ...infrastructure.agents.static_agent import StaticAnalysisAgent
# from ...infrastructure.agents.dynamic_agent import DynamicExploitationAgent
# from ...infrastructure.agents.triage import TriageAgent

logger = logging.getLogger(__name__)


class VulnerabilityTriageService:
    """Servicio principal que orquesta el flujo completo de triage de vulnerabilidades"""
    
    def __init__(
        self,
        report_repository: ReportRepository,
        vulnerability_repository: VulnerabilityRepository,
        analysis_repository: AnalysisRepository,
        triage_result_repository: TriageResultRepository
    ):
        self.report_repository = report_repository
        self.vulnerability_repository = vulnerability_repository
        self.analysis_repository = analysis_repository
        self.triage_result_repository = triage_result_repository
        
        # Inicializar agentes
        self.report_reader_agent = ReportReaderAgent(
            report_repository, vulnerability_repository
        )
        self.static_analysis_agent = StaticAnalysisAgent(
            vulnerability_repository, analysis_repository
        )
        # TODO: Inicializar otros agentes cuando estén adaptados
        # self.dynamic_agent = DynamicExploitationAgent(...)
        # self.triage_agent = TriageAgent(...)
    
    async def process_full_triage(
        self, 
        pdf_path: str, 
        source_code_directory: Optional[str] = None,
        target_url: Optional[str] = None,
        enable_static_analysis: bool = True,
        enable_dynamic_analysis: bool = False,
        enable_final_triage: bool = True
    ) -> Dict[str, Any]:
        """
        Ejecuta el flujo completo de triage de vulnerabilidades
        
        Args:
            pdf_path: Ruta al reporte PDF
            source_code_directory: Directorio del código fuente para análisis estático
            target_url: URL objetivo para análisis dinámico
            enable_static_analysis: Habilitar análisis estático
            enable_dynamic_analysis: Habilitar análisis dinámico
            enable_final_triage: Habilitar triage final
            
        Returns:
            Diccionario con resultados del proceso completo
        """
        
        logger.info(f"Iniciando triage completo para: {pdf_path}")
        results = {
            "report": None,
            "vulnerabilities": [],
            "static_analyses": [],
            "dynamic_analyses": [],
            "triage_results": [],
            "summary": {},
            "execution_time": None
        }
        
        start_time = datetime.utcnow()
        
        try:
            # Paso 1: Procesar reporte PDF
            logger.info("Paso 1: Procesando reporte PDF...")
            report = await self._process_pdf_report(pdf_path)
            results["report"] = report
            
            # Obtener vulnerabilidades del reporte
            vulnerabilities = await self.vulnerability_repository.find_by_source(f"report:{report.id}")
            results["vulnerabilities"] = vulnerabilities
            logger.info(f"Encontradas {len(vulnerabilities)} vulnerabilidades en el reporte")
            
            # Paso 2: Análisis estático (opcional)
            if enable_static_analysis and source_code_directory:
                logger.info("Paso 2: Ejecutando análisis estático...")
                static_analyses = await self._perform_static_analysis(vulnerabilities, source_code_directory)
                results["static_analyses"] = static_analyses
                logger.info(f"Completados {len(static_analyses)} análisis estáticos")
            
            # Paso 3: Análisis dinámico (opcional)
            if enable_dynamic_analysis and target_url:
                logger.info("Paso 3: Ejecutando análisis dinámico...")
                # TODO: Implementar cuando el agente dinámico esté adaptado
                # dynamic_analyses = await self._perform_dynamic_analysis(vulnerabilities, target_url)
                # results["dynamic_analyses"] = dynamic_analyses
                logger.info("Análisis dinámico no implementado aún")
            
            # Paso 4: Triage final (opcional)
            if enable_final_triage:
                logger.info("Paso 4: Ejecutando triage final...")
                # TODO: Implementar cuando el agente de triage esté adaptado
                # triage_results = await self._perform_final_triage(vulnerabilities, results["static_analyses"])
                # results["triage_results"] = triage_results
                logger.info("Triage final no implementado aún")
            
            # Generar resumen
            results["summary"] = await self._generate_summary(results)
            
            end_time = datetime.utcnow()
            results["execution_time"] = (end_time - start_time).total_seconds()
            
            logger.info(f"Triage completo finalizado en {results['execution_time']:.2f} segundos")
            return results
            
        except Exception as e:
            logger.error(f"Error durante el triage: {e}")
            raise
    
    async def _process_pdf_report(self, pdf_path: str) -> Report:
        """Procesa el reporte PDF usando el ReportReaderAgent"""
        return await self.report_reader_agent.process_pdf_report(pdf_path)
    
    async def _perform_static_analysis(self, vulnerabilities: List[Vulnerability], source_directory: str) -> List[Analysis]:
        """Ejecuta análisis estático usando el StaticAnalysisAgent"""
        return await self.static_analysis_agent.validate_vulnerabilities(vulnerabilities, source_directory)
    
    async def _perform_dynamic_analysis(self, vulnerabilities: List[Vulnerability], target_url: str) -> List[Analysis]:
        """Ejecuta análisis dinámico usando el DynamicExploitationAgent"""
        # TODO: Implementar cuando el agente dinámico esté adaptado
        pass
    
    async def _perform_final_triage(self, vulnerabilities: List[Vulnerability], analyses: List[Analysis]) -> List[TriageResult]:
        """Ejecuta triage final usando el TriageAgent"""
        # TODO: Implementar cuando el agente de triage esté adaptado
        pass
    
    async def _generate_summary(self, results: Dict[str, Any]) -> Dict[str, Any]:
        """Genera un resumen de los resultados del triage"""
        
        vulnerabilities = results.get("vulnerabilities", [])
        static_analyses = results.get("static_analyses", [])
        
        # Contar vulnerabilidades por severidad
        severity_counts = {}
        for vuln in vulnerabilities:
            severity = vuln.severity.value
            severity_counts[severity] = severity_counts.get(severity, 0) + 1
        
        # Contar análisis por estado
        analysis_status_counts = {}
        for analysis in static_analyses:
            status = analysis.status.value
            analysis_status_counts[status] = analysis_status_counts.get(status, 0) + 1
        
        return {
            "total_vulnerabilities": len(vulnerabilities),
            "vulnerabilities_by_severity": severity_counts,
            "static_analyses_completed": len(static_analyses),
            "analyses_by_status": analysis_status_counts,
            "report_info": {
                "title": results["report"].title if results["report"] else "N/A",
                "client": results["report"].client if results["report"] else "N/A",
                "processed_at": results["report"].processed_at.isoformat() if results["report"] else None
            }
        }
    
    async def get_triage_status(self, report_id: str) -> Dict[str, Any]:
        """Obtiene el estado actual del triage para un reporte específico"""
        
        # Obtener reporte
        report = await self.report_repository.find_by_id(report_id)
        if not report:
            raise ValueError(f"Reporte no encontrado: {report_id}")
        
        # Obtener vulnerabilidades
        vulnerabilities = await self.vulnerability_repository.find_by_source(f"report:{report_id}")
        
        # Obtener análisis
        analyses = []
        for vuln in vulnerabilities:
            vuln_analyses = await self.analysis_repository.find_by_vulnerability_id(vuln.id)
            analyses.extend(vuln_analyses)
        
        # Obtener resultados de triage
        triage_results = await self.triage_result_repository.find_by_report_id(report_id)
        
        return {
            "report": report,
            "vulnerabilities_count": len(vulnerabilities),
            "analyses_count": len(analyses),
            "triage_results_count": len(triage_results),
            "status": "completed" if triage_results else "in_progress"
        }